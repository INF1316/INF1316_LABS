### ALUNOS
Pedro Barizon       2211350
João Gabriel Cunha  2211302

# LABORATORIO 1 - Sistemas Operacionais

1) Faça um programa para criar dois processos, o pai escreve seu pid e espera
o filho terminar e o filho escreve o seu pid e termina.

******************************** CODIGO FONTE ********************************
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>     // fork
#include <sys/wait.h>
#include <stdio.h>      // puts
#include <stdlib.h>

void exibeMatriz(int* matriz, int lin, int col);

int main(int argc, char *argv[])
{
    int status, pid, segmento[3], *matriz[3];
    int matAux1[9] = {5, 7, 9, 6, 3, 6, 3, 1, 2};
    int matAux2[9] = {5, 3, 0, 6, 2, 6, 5, 7, 0};
    int matAux3[9] = {0}; // Matriz resultante inicializada com 0
    int* matAux[3] = {matAux1, matAux2, matAux3};
    int tamSeg = sizeof(segmento) / sizeof(segmento[0]);

    // Alocacao de memoria compartilhada
    for (int i = 0; i < tamSeg; i++)
    {
        segmento[i] = shmget(IPC_PRIVATE, 9 * sizeof(int), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
        matriz[i] = (int*)shmat(segmento[i], 0, 0);
    }

    // Preenchimento de valores usando aritmetica de ponteiros
    for (int i = 0; i < tamSeg; i++)
    {
        for (int j = 0; j < 9; j++)
        {
            *(matriz[i] + j) = *(matAux[i] + j);
        }
        printf("Matriz %d criada:\n", i + 1);
        exibeMatriz(matriz[i], 3, 3);
        printf("\n");
    }

    // Processamento: para cada linha da matriz
    for (int k = 0; k < 3; k++)
    {
        if ((pid = fork()) < 0) // Erro
        {
            puts("Ocorreu um erro na criacao do processo");
            exit(-4);
        }
        else if (pid == 0) // Processo filho
        {
            for (int i = 0; i < 3; i++)
            {
                *(matriz[2] + 3 * k + i) = *(matriz[0] + 3 * k + i) + *(matriz[1] + 3 * k + i);
            }
            exit(EXIT_SUCCESS);
        }
        else // Processo pai
        {
            printf("Linha %d preenchida:\n", k + 1);
            waitpid(pid, &status, 0);
            exibeMatriz(matriz[2], 3, 3);
            printf("\n");
        }
    }

    // Desanexar e remover segmentos de memoria compartilhada
    for (int i = 0; i < tamSeg; i++)
    {
        shmdt(matriz[i]);
        shmctl(segmento[i], IPC_RMID, 0);
    }

    return 0;
}

void exibeMatriz(int* matriz, int lin, int col)
{
    for (int i = 0; i < lin; i++)
    {
        printf("|");
        for (int j = 0; j < col; j++)
        {
            printf(" %3d", *(matriz + i * col + j));
        }
        printf("   |\n");
    }
}


############################ EXECUCAO E COMPILACAO ###########################
* Linha de compilacao:  gcc -Wall -o ex1 ex1.c
* Linha de execucao:    ./ex1


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ SAIDA $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
Matriz 1 criada:
|   5   7   9   |
|   6   3   6   |
|   3   1   2   |

Matriz 2 criada:
|   5   3   0   |
|   6   2   6   |
|   5   7   0   |

Matriz 3 criada:
|   0   0   0   |
|   0   0   0   |
|   0   0   0   |

Linha 1 preenchida:
|  10  10   9   |
|   0   0   0   |
|   0   0   0   |

Linha 2 preenchida:
|  10  10   9   |
|  12   5  12   |
|   0   0   0   |

Linha 3 preenchida:
|  10  10   9   |
|  12   5  12   |
|   8   8   2   |



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% REFLEXAO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Inicialmente, foram alocadas tres matrizes 3 x 3 linearizadas (vetores 1 x 9) na
area de memoria compartilhada por meio do comando "shmget", que retornou, para
cada chamada, um identificador de segmento. A partir dos identificadores, com o
uso de "shmat", os enderecos iniciais das matrizes foram atribuidos aos ponteiros
armazendos em "matriz". Em seguida, cada matriz foi preenchida com auxilio de
"matAux", sendo ao final exibida. Logo apos, para cada linha da matriz solucao
(a terceira), foi criado, por meio do "fork()", um processo filho responsavel por
atualizar as entradas da linha atual com a soma das entradas respectivas das outras
duas matrizes. Em todos os casos, o processo pai esperou seu filho terminar para,
enfim, exibir o estado da matriz solucao. Finalmente, o pai foi encerrado com
"return 0".

Cabe mencionar que, quando se manipularam as matrizes na regiao compartilhada, os
processos funcionaram corretamente com o uso de aritmetica de ponteiros em
detrimento de indexacao. O porque disso ainda nao nos eh sabido e, provavelmente,
envolve questoes de hardware mais minuciosas.



2) Agora, usando a mesma estrutura de processos pai e filho, declare uma
variável visível ao pai e ao filho, no pai inicialize a variável com1 e imprima
seu valor antes do fork(). No filho, altere o valor da variável para 5 e imprima
o seu valor antes do exit(). Agora, no pai, imprima novamente o valor da
variável após o filho ter alterado a variável - após a waitpid(). Justifique os
resultado obtidos.

******************************** CODIGO FONTE ********************************
#include <unistd.h>     // fork, exec
#include <sys/wait.h>   // waitpid
#include <stdio.h>
#include <stdlib.h>     // exit e NULL

int main(void)
{
    int status, var;
    /*
    int* var = (int*)malloc(sizeof(int)); NUNCA MAIS FAZER (wild pointer)

    if (!var)
        exit(EXIT_FAILURE); // Impossivel alocar memoria
    */

    if (fork() != 0) // Pai
    {
        var = 1;
        printf("valor de var no pai antes do filho: %d\n", var);

        waitpid(-1, &status, 0);

        printf("valor de var no pai depois do filho: %d\n", var);
        // free(var);
    }

    else // Filho
    {
        var = 5;
        printf("valor de var no filho: %d\n", var);
        exit(EXIT_SUCCESS);
    }

    return 0;
}


############################ EXECUCAO E COMPILACAO ###########################
* Linha de compilacao:  gcc -Wall -o ex2 ex2.c
* Linha de execucao:    ./ex2


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ SAIDA $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
Valor de var no pai antes do filho: 1
Valor de var no filho: 5
Valor de var no pai depois do filho: 1


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% REFLEXAO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
O valor de var nao foi o mesmo nos dois programas, mesmo depois do retorno do
filho ao pai. Isso se explica pelo fato de que os codigos e as variaveis dos
programas respectivos aos processos foram  armazenados em areas diferentes na
RAM. Dessa forma, nao houve compartilhamento de variaveis, ainda que estas
pudessem ter sido alocadas dinamicamente.




3) Use o programa anterior para ler e ordenar um vetor de 10 posições. O filho
ordena o vetor e o pai exibe os dados do vetor antes do fork() e depois do
waitpid(). Eles usarão o mesmo vetor na memória? Justifique.

******************************** CODIGO FONTE ********************************
#include <unistd.h>     // fork, exec
#include <sys/wait.h>   // waitpid
#include <stdio.h>
#include <stdlib.h>     // exit e NULL

void exibeVetor(int* v, int n);
void exibeVetorLn(int* v, int n);
void ordenaVetor(int* v, int n);

int main(void)
{
    int v[10], tam = sizeof(v) / sizeof(v[0]), status;

    printf("digite 10 valores inteiros:\n");

    for (int i = 0; i < tam; i++)
        fscanf(stdin, " %d", v + i);
    
    printf("antes do fork:\n");
    exibeVetorLn(v, tam);

    if (fork() != 0) // Pai
    {
        waitpid(-1, &status, 0);
        printf("depois do fork:\n");
        exibeVetorLn(v, tam);
    }

    else // Filho
    {
        ordenaVetor(v, tam);
        printf("vetor ordenado pelo filho:\n");
        exibeVetorLn(v, tam);
        exit(EXIT_SUCCESS);
    }
    
    return 0;
}

void exibeVetorLn(int* v, int n)
{
    exibeVetor(v, n);
    printf("\n");
}


void exibeVetor(int* v, int n)
{
    FILE* file = stdout;

    fprintf(file, "{ %d", v[0]);

    for (int i = 1; i < n; i++)
        fprintf(file, ", %d", v[i]);

    fprintf(file, " }");
}

void ordenaVetor(int* v, int n)
{
    int menor, aux;

    for (int i = 0; i < n; i++)
    {
        menor = i;

        for (int j = i + 1; j < n; j++)
        {
            if (v[j] < v[menor])
                menor = j;
        }

        aux = v[i];
        v[i] = v[menor];
        v[menor] = aux;
    }
}


############################ EXECUCAO E COMPILACAO ###########################
* Linha de compilacao:  gcc -Wall -o ex3 ex3.c
* Linha de execucao:    ./ex3


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ SAIDA $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
digite 10 valores inteiros:
10
1
1
1
1
13
32123
23
1
123
antes do fork:
{ 10, 1, 1, 1, 1, 13, 32123, 23, 1, 123 }
vetor ordenado pelo filho:
{ 1, 1, 1, 1, 1, 10, 13, 23, 123, 32123 }
depois do fork:
{ 10, 1, 1, 1, 1, 13, 32123, 23, 1, 123 }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% REFLEXAO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Foram exibidos dois vetores iguais, pois a ordenacao feita pelo filho nao surtiu
efeito no pai, uma vez que, como visto no exercicio anterior, os processos
lidaram com areas de memoria distintas e, portanto, vetores diferentes.




4) Modifique o programa anterior para que o filho execute um programa elaborado
por você, que mande imprimir uma mensagem qualquer no vídeo, por exemplo,
“alo mundo”. Em seguida altere o programa do item 4 para o filho executar o
programa echo da shell.

******************************** CODIGO FONTE ********************************

----------------------------------- EX4.C ------------------------------------
#include <unistd.h>     // fork, exec
#include <sys/wait.h>   // waitpid
#include <stdio.h>
#include <stdlib.h>     // exit e NULL

// Referencia https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/src/exec.html

int main(void)
{
    int status;
    const char* fileName = "echo";
    char *argv[6] = 
    {
        fileName,
        "voce consegue ouvir o ECHO?",
        "ECHO ECHO",
        "ECHO ECHO ECHO",
        "ECHO ECHO",
        "ECHO"
    };

    if (fork() != 0) // Pai
    {
        waitpid(-1, &status, 0);
        puts("fim do processo pai");
    }

    else // Filho
    {
        printf("processo filho antes do exec\n");
        // execv("alo_mundo.exe", argv);        // Exibe "alo mundo" na tela
        execv("echo", argv);                    // Replica as mensagens de argv na shell
    }

    return 0;
}


-------------------------------- ALO_MUNDO.C ---------------------------------
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    puts("alo mundo");
    
    exit(EXIT_SUCCESS); // NAO FUNCIONOU SO COM RETURN
}


------------------------------------ ECHO.C -----------------------------------
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
    for (int i = 0; i < argc; i++)
    {
        fprintf(stdout, "argv[%d]: %s\n", i, argv[i]);
    }

    exit(EXIT_SUCCESS);
}


############################ EXECUCAO E COMPILACAO ###########################
* Linhas de compilacao:
    gcc -Wall -o alo_mundo.exe alo_mundo.c
    gcc -Wall -o echo.exe echo.c
    gcc -Wall -o ex4 ex4.c
* Linha de execucao:    ./ex4


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% REFLEXAO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
O comando execv sobrescreve a area da RAM com o codigo herdado pelo filho, pondo
no lugar o codigo do programa cujo caminho foi passado como primeiro argumento
(no caso, "echo.exe"). Em seguida, argv corresponde a lista de argumentos que
serao passados ao programa, a semelhanca de quando se escrevem os argumentos em
uma console. O caso do programa alo_mundo.exe eh inteiramente analogo.
