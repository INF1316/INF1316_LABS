[INF1316] Lab #3 - Felipe de Aragão Falcão (2120360)

João Gabriel Cunha (2211302)



Número e enunciado:
1) Execute o programa ctrl-c.c”.
Digite Ctrl-C e Ctrl-\. Analise o resultado.
Neste mesmo programa, remova os
comandos signal( ) e repita o teste anterior
observando os resultados.

Código fonte:
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

#define EVER ;;

void intHandler(int sinal);
void quitHandler();

int main (void) {
    signal(SIGINT, intHandler);
    signal(SIGQUIT, quitHandler);

    for(EVER);
}

void intHandler(int sinal) {
    printf("Você pressionou Ctrl-C (%d) \n", sinal);
}

void quitHandler(){
    printf("Terminando o processo.\n");
    exit(0);
}

Linhas de comando para compilação e execução do programa:
gcc -o saida1 ctrl-c.c
./saida1

Saída gerada:
^CVocê pressionou Ctrl-C (2)
^\Terminando o processo.

Texto com uma reflexão sobre a razão de ter obtido esse resultado:
Ao executar com os "signal", um segundo parâmetro específico, permitiu-se que fosse controlado a forma de tratamento do sinal. Esse controle foi redirecionado para as funções intHandler e quitHandler.
Ao remover os comandos signal, deixou de existir um tratamento específico para cada sinal, sendo assim o tratamento padrão e tanto o CRTL-C quanto o CTRL-\ encerrando o programa.




2) Tente fazer um programa para interceptar o
sinal SIGKILL. Você conseguiu? Explique.

Código fonte:
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

#define EVER ;;

void handlerKill();

int main (void) {
    int pid = getpid();
    printf("PID: %d\n", pid);

    signal(SIGKILL, handlerKill);

    for(EVER);
}

void handlerKill() {
    printf("Programa ainda não será encerrado.\n");
}

Linhas de comando para compilação e execução do programa:
gcc -o saida2 LAB3_Ex2.c
./saida2

Linhas de comando para compilação e execução do programa no prompt secundário:
kill -s SIGKILL 120

Saída gerada:
PID: 120
Killed

Texto com uma reflexão sobre a razão de ter obtido esse resultado:
Foi criado um programa com loop infinito "for(EVER)" e para finalizar ele foi necessário matar o programa através do kill. Para isso precisou abrir um outro prompt secundário e executar o kill, gerando a mensagem killed no prompt principal e encerrando o programa.




3) Execute e explique o funcionamento de filhocidio.c

Código fonte:
#include <stdio.h>
#include <unistd.h>

int main (void) {
    fprintf(stdout, "indo dormir...\n");
    sleep(5);
    fprintf(stdout, "Acordei!\n");
   
    return 0;
}

Linhas de comando para compilação e execução do programa:
gcc -o saida3 filhocidio.c
./saida3

Saída gerada:
indo dormir...
Acordei!

Texto com uma reflexão sobre a razão de ter obtido esse resultado:
O programa printa uma mensagem ao iniciá-lo e realiza um sleep de 5 segundos, e então printa outra mensagem "acordei" quando o sleep acaba.




4) Usando SIGSTOP e SIGCONT faça um
programa que crie 2 processos filho e alterne a
execução dos filhos. Após 10 trocas de
contexto, o processo pai mata os processos
filho.
OBS: Os processos filho são formados por loops
infinitos.

Código fonte:
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>

#define EVER ;;

void loop_infinito(int filho_num) {
    for (EVER) {
        printf("Processo filho %d está executando\n", filho_num);
        sleep(1);
    }
}

int main(void) {
    int pidFilho1, pidFilho2;
    int trocas = 0;

    pidFilho1 = fork();
    if (pidFilho1 == 0) {
        loop_infinito(1);
    }

    pidFilho2 = fork();
    if (pidFilho2 == 0) {
        loop_infinito(2);
    }

    if (pidFilho1 > 0 && pidFilho2 > 0) {
        kill(pidFilho1, SIGSTOP);
        kill(pidFilho2, SIGSTOP);

        sleep(1);

        while (trocas < 10) {
            kill(pidFilho1, SIGCONT);
            sleep(1);
            kill(pidFilho1, SIGSTOP);
   
            kill(pidFilho2, SIGCONT);
            sleep(1);
            kill(pidFilho2, SIGSTOP);

            trocas++;
        }

        kill(pidFilho1, SIGKILL);
        kill(pidFilho2, SIGKILL);

        waitpid(pidFilho1, NULL, 0);
        waitpid(pidFilho2, NULL, 0);

        printf("Processos filhos terminados.\n");
    }

    return 0;
}

Linhas de comando para compilação e execução do programa:
gcc -o saida4 Lab3_Ex4.c
./saida4

Saída gerada:
Processo filho 1 está executando
Processo filho 2 está executando
Processo filho 1 está executando
Processo filho 2 está executando
Processo filho 1 está executando
Processo filho 2 está executando
Processo filho 1 está executando
Processo filho 2 está executando
Processo filho 1 está executando
Processo filho 2 está executando
Processo filho 1 está executando
Processo filho 2 está executando
Processo filho 1 está executando
Processo filho 2 está executando
Processo filho 1 está executando
Processo filho 2 está executando
Processo filho 1 está executando
Processo filho 2 está executando
Processo filho 1 está executando
Processo filho 2 está executando
Processos filhos terminados.

Texto com uma reflexão sobre a razão de ter obtido esse resultado:
Ocorre a criação do processo filho 1 e ele entra em um loop infinito, assim como ocorre com o filho 2 em seguida. Como no loop infinito tem um sleep de 1 segundo, não da tempo de executar o próximo loop ininito antes de entrar no if (pidFilho1 > 0 && pidFilho2 > 0), que é onde é enviado 2 sinais de STOP para ambos os filhos. A partir daí entra em um loop onde ocorrerá a troca de processos 10 vezes, e então, quando acabar, o pai da kill nos filhos.





5) Faça um programa que leia 2 números e
imprima o resultado das 4 operações básicas
sobre estes 2 números.
! Verifique o que acontece se o 2º. número
da entrada for 0 (zero)
! Capture o sinal de erro de floating point
(SIGFPE) e repita a experiência anterior

Código fonte:
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void signal_handler(int sig);

int main() {
    double num1, num2;
   
    signal(SIGFPE, signal_handler);

    printf("Digite o primeiro numero: ");
    scanf("%lf", &num1);

    printf("Digite o segundo numero: ");
    scanf("%lf", &num2);

    printf("\nResultados das operacoes:\n");
    printf("Adicao: %.2f + %.2f = %.2f\n", num1, num2, num1 + num2);
    printf("Subtracao: %.2f - %.2f = %.2f\n", num1, num2, num1 - num2);
    printf("Multiplicacao: %.2f * %.2f = %.2f\n", num1, num2, num1 * num2);

    if (num2 == 0) {
        printf("Erro: Tentativa de divisao por zero!\n");
        raise(SIGFPE);
    } else {
        printf("Divisao: %.2f / %.2f = %.2f\n", num1, num2, num1 / num2);
    }

    return 0;
}

void signal_handler(int sig) {
    if (sig == SIGFPE) {
        printf("Erro: Divisao por zero detectada!\n");
        exit(EXIT_FAILURE);
    }
}

Linhas de comando para compilação e execução do programa:
gcc -o saida4 Lab3_Ex5.c
./saida5

Saída gerada sem erro:
Digite o primeiro numero: 7
Digite o segundo numero: 3

Resultados das operacoes:
Adicao: 7.00 + 3.00 = 10.00
Subtracao: 7.00 - 3.00 = 4.00
Multiplicacao: 7.00 * 3.00 = 21.00
Divisao: 7.00 / 3.00 = 2.33

Saída gerada com erro:
Digite o primeiro numero: 7
Digite o segundo numero: 0

Resultados das operacoes:
Adicao: 7.00 + 0.00 = 7.00
Subtracao: 7.00 - 0.00 = 7.00
Multiplicacao: 7.00 * 0.00 = 0.00
Erro: Tentativa de divisao por zero!
Erro: Divisao por zero detectada!

Texto com uma reflexão sobre a razão de ter obtido esse resultado:
O programa lê do teclado 2 números em formato double e tenta realizar as 4 operações básicas com esses números. A adição, subtração e multiplicação não existem erros e podem ser feitas direto, mas a divisão precisa verificar o caso 0, podendo gerar sinal através do SIGFPE. O programa 1 verifica a divisão por zero de forma manual e o 2 usa o SIGFPE para verificar. Por isso a diferença na saída.




6) Faça um programa para monitorar e informar o
preço de chamadas telefônicas. O programa
deverá ser executado em background.
! O início e o término de uma chamada são
informados através dos sinais SIGUSR1 e
SIGUSR2, respectivamente.
! O custo da ligação é de 2 centavos por
segundo, para ligações de até 1 minuto ou de 1
centavo por segundo a partir do 2º. minuto, ou
seja, uma ligação de 1m30s custa R$1,50.

Código fonte:
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <time.h>

int emChamada = 0;
time_t tempoInicio;

// Manipulador para SIGUSR1
void iniciarChamada(int sig) {
    if (emChamada == 0) {
        emChamada = 1;

        printf("Chamada iniciada.\n");
        tempoInicio = time(NULL);
    }
    else {
        printf("Ja existe uma chamada em andamento.\n");
    }
}

// Manipulador para SIGUSR2
void terminarChamada(int sig) {
    if (emChamada == 1) {
        emChamada = 0;

        time_t tempoFim = time(NULL); // Pega o tempo de termino
        double duracao = difftime(tempoFim, tempoInicio);
        double custo = 0;

        if (duracao <= 60) {
            custo = duracao * 0.02;
        }
        else {
            custo = (60 * 0.02) + ((duracao - 60) * 0.01);
        }

        printf("Chamada terminada. Duracao: %.0f segundos. Custo: R$%.2f\n", duracao, custo);
    }
    else {
        printf("Nenhuma chamada em andamento para terminar.\n");
    }
}

int main() {
    signal(SIGUSR1, iniciarChamada);
    signal(SIGUSR2, terminarChamada);

    printf("Programa de monitoramento de chamadas iniciado. PID: %d\n", getpid());
    printf("Envie SIGUSR1 para iniciar uma chamada e SIGUSR2 para terminar uma chamada.\n");

    while (1) {
        pause();
    }

    return 0;
}

Linhas de comando para compilação e execução do programa:
gcc -o saida6 Lab3_Ex6.c
./saida6

Linhas de comando para compilação e execução do programa no prompt secundário:
kill -SIGUSR1 222
kill -SIGUSR2 222

Saída gerada:
Programa de monitoramento de chamadas iniciado. PID: 222
Envie SIGUSR1 para iniciar uma chamada e SIGUSR2 para terminar uma chamada.
Chamada iniciada.
Chamada terminada. Duracao: 82 segundos. Custo: R$1.42

Texto com uma reflexão sobre a razão de ter obtido esse resultado:
O programa começa mudando o signal aceitado para SIGUSR1 e SIGUSR2, e então entra em um loop infinito.
A partir daí o programa só espera algum desses 2 sinais, podendo iniciar ou terminar uma ligação.
Ao iniciar começa a marcar o tempo, para quando terminar o tempo ser convertido em um valor em dinheiro. 